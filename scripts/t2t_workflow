#!/usr/bin/env python
# File created on 02 Mar 2011
from __future__ import division

__author__ = "Daniel McDonald"
__copyright__ = "Copyright 2011, The tax2tree project"
__credits__ = ["Daniel McDonald"]
__license__ = "GPL"
__version__ = "1.0"
__maintainer__ = "Daniel McDonald"
__email__ = "mcdonadt@colorado.edu"
__status__ = "Development"

from optparse import make_option
from cogent.util.misc import parse_command_line_parameters
from cogent.parse.fasta import MinimalFastaParser
from cogent.app.fasttree import build_tree_from_alignment
import os
from subprocess import Popen
from t2t.nlevel import nlevel_workflow, load_consensus_map, load_tree, \
        make_consensus_tree
from t2t.util import reroot, combine_alignments


script_info = {}
script_info['brief_description'] = "tax2tree workflow script"
script_info['script_description'] = "Greengenes tax2tree workflow script for decorating taxonomy"
script_info['script_usage'] = [("","","")]
script_info['output_description']= ""
script_info['required_options']=[make_option('--tree','-t',dest='tree',\
                    help='Input tree'),
              make_option('--consensus-map','-m',dest='consensus_map',\
                    help='Input consensus map'),
              make_option('--output','-o', dest='output',\
                    help='Output directory')]

script_info['optional_options']=[make_option('--reroot','-r',dest='reroot',\
                    help="Tipnames to reroot off off"),
              make_option('--classify','-c',dest='classify',
                    help="Sequences to classify"),
              make_option('--pynast-template','-p',dest='pynast_template',
                    help="PyNAST template for aligning sequences to classify"),
              make_option('--seed-alignment','-a',dest='seed_alignment',
                    help="Seed alignment with taxonomy information")]

script_info['version'] = __version__

def main():
    option_parser, opts, args = parse_command_line_parameters(**script_info)

    if not opts.output:
        option_parser.error("No output directory specified!")

    if os.exists(opts.output):
        option_parser.error("Output directory already exists!")

    mkdir(opts.output)

    if opts.classify:
        if not opts.seed_alignment:
            option_parser.error("Seed alignment not specified!")

        if opts.tree:
            option_parser.error("Conflicting options! Tree is build de novo")

        classify_fp = open(opts.classify)
        seed_aln_fp = open(opts.seed_alignment)
        seed_name = opts.seed_alignment.rsplit('.',1)[0] # expect .fasta or .fna

        if alignment_length(classify_fp) != alignment_length(seed_aln_fp):
            if opts.verbose:
                print "Classify sequences are not aligned to seed, realigning with PyNAST"
            output_name = os.path.join(opts.output, '%s + pynast_aligned' % opts.classify)
            proc = Popen('pynast -i %s -t %s -o %s -a %s' % (opts.classify, \
                    opts.seed_alignment, opts.output, output_name), shell=True)

            if proc.wait() != 0:
                raise ValueError, "PyNAST exited with non-zero!"

            seqs = combine_alignments(open(output_name), seed_aln_fp)
            # mask!!
        else:        
            seqs = combine_alignments(classify_fp, seed_aln_fp)

        # output combined sequences
        seed_klass_name = seed_name + '_klass'
        f = open(os.path.join(opts.output, seed_klass_name + '.fasta'),'w')
        f.write(fasta_from_alignment(seqs))
        f.close()

        ft_params = {'-nt':True,'-gamma':True,'-fastest':True,'-no2nd':True,
                     '-spr':4}
        tree = build_tree_from_alignment(seqs, Params=params)
        opts.tree = os.path.join(opts.output, seed_klass_name + '.ntree')
        f = open(os.path.join(opts.tree,'w'))
        f.write(tree.getNewick(with_distances=True))
        f.close()
    else:
        tree = DndParser(opts.tree)

    tree_name = opts.tree.rsplit('.',1)[0]

    # load up initial data for nlevel
    con_map = load_consensus_map(opts.consensus_map, verbose=opts.verbose)
    tree = load_tree(opts.tree, con_map)
    contree, contree_lookup = make_consensus_tree(con_map.values())

    if opts.reroot:
        ids = [l.strip() for l in open(opts.reroot)]
        tree = reroot(tree, ids) ### ugh... might destroy .Bootstrap and .Consensus
        tree_name += '-rerooted'
        f = open(tree_name + '.ntree','w')
        f.write(tree.getNewick(with_distances=True))
        f.close()

    dec_tree = nlevel_workflow(tree, contree_lookup, opts.verbose)

    new_con_map = pull_consensus_strings(dec_tree, opts.verbose)
    f = open(tree_name + '-consensus.txt', 'w')
    f.write('\n'.join(new_con_map))
    f.close()

    save_bootstraps(tree, opts.verbose)
    f = open(tree_name + '-dec.ntree','w')
    f.write(dec_tree.getNewick(with_distances=True))
    f.close()

if __name__ == "__main__":
    main()
